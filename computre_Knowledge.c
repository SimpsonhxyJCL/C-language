//计算机基础知识点

////2021年1月31日14:08:03
///*计算机系统*/
////**世界上第一台计算器的诞生：1946年-宾夕法尼亚大学 。冯，诺依曼1946年提出“储存程序控制”被称为现代计算机之父。
////**计算机的的四个发展时代：（依据自身物理器件的不同）1.电子管时代 2.晶体管时代 3.小规模集成电路时代
////4.大规模集成电路时代。
////**计算机的基本组成：计算机系统包括：硬件系统(电、磁、光、机械原理有机构成的物理部件)+软件系统（程序数据文档） 。
////**硬件系统：主机+外部设备  *主机包括：中央处理器（运算器+控制器）+主存储器。  
////                         *外部设备包括：输入/输出设备， 辅助存储器。
///*软件系统：系统软件+应用软件 。
//* 系统软件：操作系统+语言处理系统+数据库管理系统+系统辅助处理系统。
//*  应用系统：信息管理系统+文字处理+设计软件+图形图像处理+各种程序包。
//
// *中央处理器：Central Processing Unit,CPU 是计算器运算和控制的核心。
//   1.运算器：负责对数据进行加工处理（对数据进行算术运算和逻辑运算）
//   2.控制器：负责对程序所规定的的指令进行分析、控制。并协调输入/输出操作。或者控制对主存储器的访问。
//   3.寄存器，运算器和控制器都包含寄存器，寄存器是高速存储区域，用来暂时存放参与运算的数据和运算结果。
//*CPU的主要性能指标：字长、主频、运算速度。
//   1.字长：cpu一次能处理的二进制数据的位数。字长越长，计算机的数据处理速度越快。
//   2.主频：指CPU的时钟频率，每个时钟信号周期内完成一部操作。主频越高，CPU的处理速度越快。
//     计算机cpu的主频（主频=外频×倍频），一般的可以理解为cpu的时钟的震荡频率，它是衡量计算机性能的一项重要指标，
//     很大程度（不完全是）决定了计算机的速度。
//     由于CPU是在半导体硅片上制造的，在硅片上的元件之间需要导线进行联接，由于在高频状态下要求导线越细越短越好，
//    这样才能减小导线分布电容等杂散干扰以保证CPU运算正确。 因此受制造工艺的限制，是CPU主频发展的最大障碍之一。
//   3.运算速度：指CPU每秒所能执行的加法指令数目，常用百万次/秒。
//
//*存储器：存储器是存储程序和数据的部件。主存储器（内存），辅助存储器（外存）硬盘（机械硬盘HDD、固态硬盘SSD）。
// 存储方式分类：随机存储器 Random Access Memory,RAM）、只读存储器（Read Only memory.ROM）.均半导体存储器。
//   1.RAM特性：信息可读、可写。断电后数据消失，且无法恢复。RAM分为动态和静态RAM。
//      静态 RAM (static RAM,SRAM)特点是：集成度低，价格高，存储速度快，无需刷新。
//      动态 RAM （Dynamic RAM,DRAM）特点是：集成度高，价格低，存储慢，要刷新。各类计算机采用DRAM.
//   2.ROM特性：ROM中信息只能读出不能写入。CPU执行程序时不能去写，只能读。单片机烧录程序就是写ROM。
//                                                               具有内容的永久性，断电后信息不会丢失。
// 存储器的主要性能：速度和容量，速度越快，容量越大，价格越高。性能越好。
//
// **/
// //2021年2月2日15:41:23
// 
// /* 外部设备（外设）*/
///* 1.输入/输出设备 2.辅助存储器（外部存储设备） 3.I/O接口 4.特殊业务范围的终端设备。
//* *1.输入/输出设备
//*         *输入设备：向计算机输入数据的和信息的设备。输入原始数据或程序。
//*         常用输入设备有：键盘、鼠标、摄像头、扫描仪、语音输入设备，触感器。
//*         *输出设备：将计算机的计算结果以图像、声音的形式表示出来。
//*         常见的输出设备有：显示器、音箱、打印机、投影仪。
//* *******有些设备同时集成了输入和输出两种功能，如 光盘刻录机！
//* *2.辅助存储器
//*    辅助存储器可存放大量的程序和数据，并且断电后数据不会丢失。
//*    目前常见的辅助存储器有:硬盘，闪存（U盘、SIM卡（电话卡）SD卡（相机，可覆写保护lock）
//     TF卡（手机存储卡）、记忆棒），光盘。
//***3.硬盘原理  HHD SSD
//     HHD 机械硬盘：固定磁头硬盘、活动磁头硬盘。磁头（读写磁道的数据）和磁臂是主要组成部分。
//     固定磁头;每个磁道有一个磁头、无径向移动。速度快，造价高。
//     活动磁头：每个盘面只有一个磁头，磁头需径向移动，增加寻道时间，速度慢，目前比较常用。
// *** 硬盘寻址用的磁盘地址应该由：硬盘号、记录面（磁头）号、圆柱面（磁道）号、扇区号等字段组成。
// *** 磁盘存储器的主要指标：存储密度、存储容量、平均存储时间、数据传输率。   
// ** I/O接口
//    通过I/O接口，可实现主机与外设之间的信息交换。
//    1.I/O接口的功能
//      *实现主机与外设的通信联络控制。
//      *进行地址译码和设备选择。
//      * 实现数据缓存以匹配速度。
//      * 信号格式的转换（电平转换、并/串或串/并转换、模/数转换）
//      * 传输控制命令和状态信息。
//     2.I/O方式
//       I/O方式包括：程序查询方式、程序中断方式、直接存储器存取方式、DMA（Direct Memory Access）方式、
//                    I/O通道控制方式。
//*/
///***总线***
//*  总线是一组被多个部件“分时共享”的公共信息传输路线。
//*  分时：指同一时刻总线上只能传输一个部件的信息。
//   共享：指总线上可以“挂接”多个部件，各个部件都可以通过公共线路线传输。
//*总线分类：
//   1.片内总线：指芯片内部的总线。如CPU内部寄存器与寄存器之间，寄存器与算术逻辑单元之间有片内总线连接交流信息。
//   2.系统总线（内部总线）：指计算机系统内部内部各功能部件（CPU、内存）之间相互连接的的总线。
//   3.通信总线：由于计算机设备之间的通讯，或者计算机与其他设备之间的信息传输总线。
//*/
//
//
//
////2021年2月15日15:32:30
///***计算机的工作原理***/
//* 计算机在执行程序时需将要执行的相关程序数据放入到内存中，供CPU寄存区读取，并由计算机的逻辑运算器~
//* 执行指令（一串二进制代码），如此循环，直到整个程序被执行完毕。最后把结果放入到指定的储存器地址中。
//*  可被计算机执行的二进制代码包含两方面的信息：1.操作码 、2.操作数（地址码）。
//* 1.操作码也是二进制代码，它指明指令所要完成操作的性质和功能。
//* 2.操作数指明操作码执行的操作对象。
//*/
///***数据的内部表示***
//// 1字节（byte）=8 位 （bit）,8个0、1的二进制位。0、1代表电信号，高低电平。
//  计算机存储数据，整型数以二进制补码的形式存储。内存有大端小端之分：描述字节存放的顺序，数据的高位和内存的高位地址是否一致。
//若 数字的高位存在内存地址的高位，则是小端存储模式。如果数字高位和内存高位不一致对应，则是大端存储模式。 




//时间：2021年3月7日17:28:20
/*计算机操作系统*/
//计算机操作系统是最基本和最核心的系统软件之一，其它所有软件都依赖操作系统的支持。
//操作系统是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。
//主要作用是管理好硬件设备，提高硬件设备的利用率和系统的吞吐量，并为用户和应用程序提供接口，便于使用。
//操作系统对5个方面的管理。
//1.处理器（进程）管理：主要是对进程的创建和撤销。
//2.存储器管理：为多道程序运行提供良好的环境，提高存储器的利用率。从逻辑上扩充内存。
//3.设备管理：完成用户进程提供的I/O的请求。
//4.文件管理：保证用户文件和系统文件的安全性。
//5.提供用户接口：为方便使用，提供了用户和操作系统的接口。
//操作系统的经历如下的发展过程：手工操作、批处理系统、道程序系统、实时操作系统、网路操作系统、分布式操作系统、
// 嵌入式操作系统。
//**进程管理，进程的并发执行，程序只有经过执行才能得到结果，程序的执行又分为顺序执行和并发执行。
// 顺序执行：具有封闭性，顺序性，可再现性。一个具有独立功能的程序独占处理器，直至执行结束的过程。
// 并发执行：指在一定逻辑上互相独立的程序或程序段在执行过程中，其执行时间在客观上相互重叠，一个未结束，另一个以开始。
// 并发程序执行过程特点:失去了封闭性，不可再现性，间断性（程序之间可以相互制约）。
// 并发程序具有并行性和共享性。顺序程序具有顺序性、封闭性的基本特征。
// 进程基本概念：进程是指一个具有独立功能的程序关于某个数据集合的一次运行活动。也就是，指可以并发执行的程序的执行过程。
//* 线程：比进程更小的能独立运行的基本单位。用它来提高程序的并行程度，减小系统开销，从而进一步提高系统的吞吐量。
//* 死锁：因“无知地”相互等待对方所占有的资源而无限的等待，这种状态称为死锁。
// ***程序时一组指令集，是静态的一个概念。进程是程序在处理器上一次执行的过程，是动态的概念。
//*** 进程具有一定的生命周期，它能动态的产生和消亡。程序作为一种软件资源长期保存。它的存在是永久的。
//进程包括程序和数据。一个程序可能对应多个进程，一个进程可能对应多个程序。
//* 进程活动一般分为五个基本状态：1.运行状态 2.就绪状态 3.等待状态 4.创建状态 5.终止状态。
// 运行状态：进程占有处理器、正在运行的状态。
// 就绪状态：进程具备运行条件，等待系统分配处理器以便进入运行的状态。
// 等待状态：又称阻塞状态、或者睡眠状态，指进程不具备运行条件，正在等待某个事件完成的状态。
// 创建状态：进程正在创建过程中，尚不能运行的状态。
// 终止状态：进程运行结束的状态。
//*****内存管理
// 存储管理是操作系统的重要组成部分，管理的主要对象是内存，操作系统的主要任务之一是尽可能方便用户使用和提高内存利用率。


// I/O设备管理。





//时间：2021年3月23日21:15:28
/* 2022 考研备考数据结构 昆工电子信息工程 专业课初试笔试科目 */
/****  数据结构与算法  ****/


/**************************************************************************

 学习思路：1.多画图、多思考。 2.死磕代码、多写代码。
           3.多刷题。参考 LeetCode、牛客网、剑指offer 三个平台的资料。

***************************************************************************/
///算法是指对解题方案的准确而完整的描述，简单的说算法就是解决问题的操作步骤。程序可以描述算法。
/// 算法的基本特征：可行性（步骤可以实现),确定性（步骤明确），有穷性（有限时间内完成）。拥有足够的情报。
/// 
/// 算法效率性能比较：时间效率：算法时间复杂度（计算工作量），空间效率：空间复杂度（存储空间），硬件内存如今足够用。

//算法的时间复杂度：执行算法所需要计算的工作量（大概的循环的次数），不等于算法程序执行的具体时间。和硬件有关。
/// 
/// 算法的时间复杂度的表示方法:大0的渐进表示法。O(n），算次数最高的项，忽略系数项，用1代替加法的常数项。
///
/// 算法的空间复杂度：执行这个算法所需要的存储空间。在嵌入式开发中比较在乎存储空间的大小。
/// 算法的空间复杂度不计算空间，计算大概定义的变量个数。如为常数个变量，空间复杂度为：O(1) 
/// 
/// 算法执行所需要的存储空间包括三部分：输入数据所占的存储空间、程序本身所占的存储空间、算法执行过程中所需要的额外空间。
/// 为了降低算法的空间复杂度，主要应减少输入数据所占的存储空间和额外空间。采用压缩存储的技术来实现。

/// 数据结构是指：相互有关联的数据元素的集合。数据就是处理数据化元素的集合，结构就是关系。
// /数据结构就是：集合中各个元素之间存在的某种关系。对计算机的数据有效的使用的各种数据组织形式。
//                不同的数据结构各自对应不同的应用场景，旨在降低各种算的的时间与空间复杂度，达到程序最佳的执行效率。
//   数据结构的基本运算：修改、插入、删除、查找、排序。
///* 常见的数据结构可分为「线性数据结构」与「非线性数据结构」。
/// //线性结构：有限个性质相同的数据元素组成的序列。
/// 具体为：线性数据结构(liner date structure)->「数组](array)、「链表](linked list)、「栈」(stack)、「队列」(queue).
///        非线性数据结构(non-linear data structrre) ->「树」(tree)、「图」(grap) [列表」(hashing)、「堆」(heap)。


//******************************************************************************************************************** 
/*
  数组[arry]------连续存储
   数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。
   构建此数组需要在初始化时给定长度，并对数组每个索引元素赋值，
   代码如下：*/
   
   //int arry[5];   //初始化一个长度为 5 的整型数组。
   // arry[0] = 1;//初始化每个元素。也就是元素赋值。数组元素的下标从0开始。
   // arrr[1] = 2;
   // arry[2] = 3;
   // arry[3] = 4;
   // arry[4] = 5;
   //或者另一种方式 int arry[5]={1,2,3,4,5,};

/* 可变数组 是经常使用的数组结构类型，其基于数组和扩容机制实现，相比于普通数组更加灵活。
    常用的操作有：访问操作、添加元素、删除元素。 
    代码如下：*/
    ////c++代码指令 初始化可变数组
    // vector<int> arry;
    // //向尾部添加元素
    // arry.push_back(2);
    // arry.push_back(0);
    // arry.push_back(1);
    // arry.push_back(3);
    // arry.push_back(2);


//*******************************************************************************************************************
/* 链表[lined list]-----离散存储（非连续存储）
   链表以节点为单位，每个元素都是一个独立的对象。在内存空间的存储是非连续的。
   链表的节点对象有两个成员变量：值[Val],后继节点 [next].
    代码如下： c++ */

//struct ListNode
//{
//    int val;  //节点值。
//    ListNode *next;//后继节点引用。
//    ListNode(int x) :val(x), next(NULL) {}
//
//    //实例化节点
//    ListNode* n1 = new ListNode(3);// 节点 head.val=3,head.next=(2),顺序是3->2->1的链表。
//    ListNode* n2 = new ListNode(2);
//    ListNode* n2 = new ListNode(1);
//     
//    //构建引用指向
//    n1->next = n2;
//    n2->next = n3;
//};


//****************************************************************************************************************   
/* 栈[stack] 
   一种具有（先入后出）特点的抽象数据结构，可使用数组或链表实现。
   仅限在表尾进行插入或删除的操作得到现性表。
    代码：c++ */
    //stack<int> stk;// 定义？
    ////入栈 push() 和出栈(pop) 操作：
    //stk.push(1); //元素1 入栈
    //stk.push(2); //元素2 入栈
    //stk.pop();  //2 出栈
    //stl.pop();  // 元素 1 出栈。


//******************0***************************************************************************************************
/* 队列 
   队列是具有先进先出特点的数据结构，可以用链表实现 。
   代码实现：c++*/
 //queue<int>que
 ////通常操作 入队：push(),出队 pop(),
 //que.push(1);// 元素1入队，
 //que.push(2);//元素2 入队，
 //que.pop(); //元素1 出队。
 //que.pop(); // 元素2 出队。


//******************************************************************************************************************
 /* 树 ----非线性结构
    树是一种非线性结构，根据字节点的数量可以分为【二叉树】和【多叉树】，最顶层的节点称为【根节点】。
    以二叉树为例：每个节点包含三个成员变量，值（val）、左子节点(left)、右子节点(right).
    代码实现：*/
 /* 若干个子树，可以组成森林，也就是将一个树的根节点去掉，剩下的若干个子树，可以组成森林。*/
//struct TreeNode 
//{
//    int val;
//    TreeNode* left;
//    TreeNode* right;
//    TreeNode(int x) :val(x), left(NULL), right(NULL) {}
//};

//建立二叉树需要实例化每个节点，并构建各节点的应用指向。
// 初始化节点
//TreeNode* n1 = new TreeNode(3);//根节点
//TreeNode* n2 = new TreeNode(2);
//TreeNode* n3 = new TreeNode(1);
//TreeNode* n4 = new TreeNode(0);
//TreeNode* n5 = new TreeNode(1);
//
////构建引用指向
//n1->lift = n2;
//n1->right = n3;
//n2->left = n4;
//n2->right = n5;

//树形结构的知识点：
/*  1.二叉树的基本概念
*   2.二叉树的遍历
*   3.线索二叉树
*   4.二叉树的应用：二叉排序、平衡二叉树、哈夫曼树及哈夫曼编码。
*   5.树和森林、树的存储结构、树 和森林、二叉树的转换、树的应用并查集。 
* 
*  树中度的概念：树中一个节点的子节点的个数称为该节点的度。
*                树中最大的度称为树的度。
*  二叉树的顺序存储：
*                用一组连续的存储单元一次自下而上、自左而右存储完全二叉数上的节点元素。
*  二叉树的链式存储：
*                用链表来存放一棵二叉树，二叉树中每个节点用链表的一个链结点来存储。
*/ 


//*****************************************************************************************************************
/* 图  */
//图是一种非线性结构。由顶点和边组成。每条边连接一对顶点。根据边的有无，图分为：有向图（A,B）和无向图<A,B>。
 //图的两种通常表示方法：邻接矩阵、邻接表。
/* 
  1.邻接矩阵：代码：C++
  //使用数组 vertices 储存顶点,(vertex 顶点，复数：vertices).使用邻接矩阵 edges 储存边。
     edges[i][j]代表节点i+1, 和节点j+1 之间是否有边。
   代码如下： 
    int vertices[5]={1,2,3,4,5};  //分别代表1 2 3 4 5 五个顶点。

    int  edges[5][5]={{0,1,1,1,1}, // i 行 j 列为1，则顶点i 与j 之间存在边。
                      {1,0,0,1,0},
                      {1,0,0,0,1},
                      {1,1,0,0,1},   
                      {1,0,1,1,0}};
   2.邻接表：
    //使用数组 vertices 存储顶点，邻接表 edges 储存边。edges 是一个二维容器。第一维 i 代表顶点索引，
     第二维 edges[i] 存储此顶点对应的边集合；例如 edges[0]=[1,2,3,4]代表 vertices[0] 的边集合为[1,2,3,4].
     代码实现：C++
     int vertices[5]={1,2,3,4,5};
     vector<vector<int>> edges;

     vector<itn> edge_1={1,2,3,4};
     vector<int> edge_2={0,3};
     vector<int> edge_3={0,4};
     vector<int> edge_4= {0,1,4};
     vector<int> edge_5={0,2,3};
     
     edges.push_back(edge_1);
     edges.push_back(edge_2);
     edges.pish_back(edge_3);
     edges.push_back(edge_4);
     edges.push_back(edge_5);

 比较  邻接矩阵 VS 邻接表：
      邻接矩阵大小只与节点的数量有关，即N^2,其中N是节点。因此，当变得数量明显小于节点数的时候。
      使用邻接矩阵存储图时会造成较大的内存浪费。
      因此，邻接表适合存储稀疏图（顶点较多，边较少）。邻接矩阵 适合存储稠密图（顶点较少、边较多）。
*/

//******************************************************************************************************************
/* 散列表 */
/*   散列表是一种非线性数据结构，通过 Hash 函数将指定的[键 key]映射至对应的值[值 value],以实现高效的元素查找。
     设想一个简单的场景：小李、小王、小白的学号为100、101、102，若现在需要从[姓名]查找[学号]。
     则可以通过建立姓名为key,学号为value 的散列表。
     代码实现如下：C++
        //初始化散列表
        unordered_map<string, int>dic;

        //添加key -> value 键值对。
        dic["小李"]=100；
        dic["小王"]=101；
        dic["小白"]=102；

        //从姓名查找学号
        dic.find("小李")->second;// ->100
        dic.find("小王")->second;// ->101
        dic.find("小白")->second; //->102

 *****************************   自行设计的 Hash 函数  *********************************
 需求假设：从学号查找姓名。
          //将三人的姓名存储至一下的数组中，则个姓名的索引分别为：0,1,2.
          string names[]={"小李","小王","小白"};
          //此时我们构造一个简单的Hash 函数，公式如下；hash(key)=(kry-1)%100.
          int hash(int id)
          {
               int index=(id-1)%100;
               return index;
          }
        //则我们构建了以学号为 key、姓名对应的数组索引为 value 得我散列表。利用Hash 函数，则可在O（1）时间复杂度
        下，通过学号查找到姓名，即：
        name[hash(100)];//小李
        name[hash(101)];//小王
        name[hash(102)];//小白

        以上设计是适用于此示例，实际hash 函数需保证 低碰撞率、高鲁棒性。以适应于各类数据和场景。
 */


//*******************************************************************************************************************
/* 堆 */
/* 堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」。
   基于堆实现的数据结构为「优先队列」。
   堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。

   完全二叉树定义： 设二叉树深度为 k，若二叉树除第 k 层外的其它各层（第 1至 k - 1层）的节点达到最大个数，
   且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。

   通过使用[优先队列]的压入 push(),和 弹出 pop() 操作，即可完成堆排序。
   代码实现：C++
   //初始化小顶堆
   priority_queue<int,vrctor<int>,greater<int>> haep;

   //元素入堆
   heap.push(1);
   heap.push(2);
   heap,push(3);

   //元素出堆（从小到大）
   heap.pop(1);
   heap.pop(2);
   heap.pop(3);
*/
//作者：Krahets /***************************************************************
//链接：https ://leetcode-cn.com/leetbook/read/illustration-of-algorithm/50e446/
//*******************************************************************************

//***** 消失的数字 *****//
// LeetCode 题目。
//按位异或运算。
/*
 for (size_t i = 0; i < length; i++)
{

}
*/

//时间：2021年4月1日14:54:00
/***** 指针 *******/
//指针的类型：
/* 1.int *p P是整型类型的指针。
*  2.float *p p是浮点型的指针。
*  3.空类型 void * p ,p是无类型的指针。可以进行强制类型的转换。

*/
/*
* 1.指针数组：存放指针地址的数组。数组的每个元素为一个指针（命名地址的变量）。
* 2.数组指针：指向数组的指针，指向数组的首元素地址。
* 3.函数指针：指向函数的指针。
* 4.


*/
//野指针的三个为题:
// 1.局部指针未初始化。 -->指针初始化。
// 2.指针越界访问地址内存。 -->小心指针越界。
// 3.指针指向的空间已经释放。-->注意，返回局部变量的地址。
// 4.指针在使用之前，先检测指针的有效性。
// 空指针：若指针使用时不知道指向谁，则可以将地址赋为空地址。
//         如int *p=NULL 将指针P 赋值为空地址。



/***** 自定义类型  *****/
//时间：2021年4月1日17:14:34
/***********************************************************************************************************************/
/* 
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
自定义类型：结构体、枚举、联合。
  结构体：一些不同类型成员变量的集合。
       1.结构体类型的声明
       2.结构体的自引用
       3.结构体变量的定义和初始化
       4.结构体内存对齐
       5.结构体传参
       6.结构体实现位段（位段的填充&可移植性）
 枚举：
       1.枚举类型的定义
       2.枚举的优点:
          为什么不使用 #define 定义常量。为啥要用枚举呢。
          1.增加代码的可读性和可维护性。
          2.和#define 相比枚举有类型检查，更加严谨。
          3.一次可以定义多个常量，方便使用，便于调试 ，防止命名污染（封装）。

       3.枚举的使用
 联合：
       1.联合的定义：可定义不同类型和长度的对象变量。
       2.联合的特点:在不同时刻，共用内存的机制。联合提供了一种方式，在单块存储区中管理不同类型的数据。
       3.联合大小的计算：至少是成员中的最大类型，或最大成员对齐数的整数倍。
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////







*/







/***********************************************************************************************************************/
/*** 软件工程基础和程序设计 ***/





/***********************************************************************************************************************/
/*****  数据库设计  *****/





